{"ast":null,"code":"import { freqIsDailyOrGreater } from '../types';\nimport dateutil from '../dateutil';\nimport Iterinfo from '../iterinfo/index';\nimport RRule from '../rrule';\nimport { buildTimeset } from '../parseoptions';\nimport { notEmpty, includes, isPresent } from '../helpers';\nimport { DateWithZone } from '../datewithzone';\nimport { buildPoslist } from './poslist';\nimport { DateTime } from '../datetime';\nexport function iter(iterResult, options) {\n  var dtstart = options.dtstart,\n      freq = options.freq,\n      interval = options.interval,\n      until = options.until,\n      bysetpos = options.bysetpos;\n  var count = options.count;\n\n  if (count === 0 || interval === 0) {\n    return emitResult(iterResult);\n  }\n\n  var counterDate = DateTime.fromDate(dtstart);\n  var ii = new Iterinfo(options);\n  ii.rebuild(counterDate.year, counterDate.month);\n  var timeset = makeTimeset(ii, counterDate, options);\n\n  while (true) {\n    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day),\n        dayset = _a[0],\n        start = _a[1],\n        end = _a[2];\n\n    var filtered = removeFilteredDays(dayset, start, end, ii, options);\n\n    if (notEmpty(bysetpos)) {\n      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);\n\n      for (var j = 0; j < poslist.length; j++) {\n        var res = poslist[j];\n\n        if (until && res > until) {\n          return emitResult(iterResult);\n        }\n\n        if (res >= dtstart) {\n          var rezonedDate = rezoneIfNeeded(res, options);\n\n          if (!iterResult.accept(rezonedDate)) {\n            return emitResult(iterResult);\n          }\n\n          if (count) {\n            --count;\n\n            if (!count) {\n              return emitResult(iterResult);\n            }\n          }\n        }\n      }\n    } else {\n      for (var j = start; j < end; j++) {\n        var currentDay = dayset[j];\n\n        if (!isPresent(currentDay)) {\n          continue;\n        }\n\n        var date = dateutil.fromOrdinal(ii.yearordinal + currentDay);\n\n        for (var k = 0; k < timeset.length; k++) {\n          var time = timeset[k];\n          var res = dateutil.combine(date, time);\n\n          if (until && res > until) {\n            return emitResult(iterResult);\n          }\n\n          if (res >= dtstart) {\n            var rezonedDate = rezoneIfNeeded(res, options);\n\n            if (!iterResult.accept(rezonedDate)) {\n              return emitResult(iterResult);\n            }\n\n            if (count) {\n              --count;\n\n              if (!count) {\n                return emitResult(iterResult);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (options.interval === 0) {\n      return emitResult(iterResult);\n    } // Handle frequency and interval\n\n\n    counterDate.add(options, filtered);\n\n    if (counterDate.year > dateutil.MAXYEAR) {\n      return emitResult(iterResult);\n    }\n\n    if (!freqIsDailyOrGreater(freq)) {\n      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);\n    }\n\n    ii.rebuild(counterDate.year, counterDate.month);\n  }\n}\n\nfunction isFiltered(ii, currentDay, options) {\n  var bymonth = options.bymonth,\n      byweekno = options.byweekno,\n      byweekday = options.byweekday,\n      byeaster = options.byeaster,\n      bymonthday = options.bymonthday,\n      bynmonthday = options.bynmonthday,\n      byyearday = options.byyearday;\n  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));\n}\n\nfunction rezoneIfNeeded(date, options) {\n  return new DateWithZone(date, options.tzid).rezonedDate();\n}\n\nfunction emitResult(iterResult) {\n  return iterResult.getValue();\n}\n\nfunction removeFilteredDays(dayset, start, end, ii, options) {\n  var filtered = false;\n\n  for (var dayCounter = start; dayCounter < end; dayCounter++) {\n    var currentDay = dayset[dayCounter];\n    filtered = isFiltered(ii, currentDay, options);\n    if (filtered) dayset[currentDay] = null;\n  }\n\n  return filtered;\n}\n\nfunction makeTimeset(ii, counterDate, options) {\n  var freq = options.freq,\n      byhour = options.byhour,\n      byminute = options.byminute,\n      bysecond = options.bysecond;\n\n  if (freqIsDailyOrGreater(freq)) {\n    return buildTimeset(options);\n  }\n\n  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {\n    return [];\n  }\n\n  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);\n}","map":null,"metadata":{},"sourceType":"module"}