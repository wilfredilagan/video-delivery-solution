{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport RRule from './rrule';\nimport dateutil from './dateutil';\nimport { includes } from './helpers';\nimport { iterSet } from './iterset';\nimport { rrulestr } from './rrulestr';\nimport { optionsToString } from './optionstostring';\n\nfunction createGetterSetter(fieldName) {\n  var _this = this;\n\n  return function (field) {\n    if (field !== undefined) {\n      _this[\"_\" + fieldName] = field;\n    }\n\n    if (_this[\"_\" + fieldName] !== undefined) {\n      return _this[\"_\" + fieldName];\n    }\n\n    for (var i = 0; i < _this._rrule.length; i++) {\n      var field_1 = _this._rrule[i].origOptions[fieldName];\n\n      if (field_1) {\n        return field_1;\n      }\n    }\n  };\n}\n\nvar RRuleSet =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(RRuleSet, _super);\n  /**\n   *\n   * @param {Boolean?} noCache\n   *  The same stratagy as RRule on cache, default to false\n   * @constructor\n   */\n\n\n  function RRuleSet(noCache) {\n    if (noCache === void 0) {\n      noCache = false;\n    }\n\n    var _this = _super.call(this, {}, noCache) || this;\n\n    _this.dtstart = createGetterSetter.apply(_this, ['dtstart']);\n    _this.tzid = createGetterSetter.apply(_this, ['tzid']);\n    _this._rrule = [];\n    _this._rdate = [];\n    _this._exrule = [];\n    _this._exdate = [];\n    return _this;\n  }\n\n  RRuleSet.prototype._iter = function (iterResult) {\n    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());\n  };\n  /**\n   * Adds an RRule to the set\n   *\n   * @param {RRule}\n   */\n\n\n  RRuleSet.prototype.rrule = function (rrule) {\n    _addRule(rrule, this._rrule);\n  };\n  /**\n   * Adds an EXRULE to the set\n   *\n   * @param {RRule}\n   */\n\n\n  RRuleSet.prototype.exrule = function (rrule) {\n    _addRule(rrule, this._exrule);\n  };\n  /**\n   * Adds an RDate to the set\n   *\n   * @param {Date}\n   */\n\n\n  RRuleSet.prototype.rdate = function (date) {\n    _addDate(date, this._rdate);\n  };\n  /**\n   * Adds an EXDATE to the set\n   *\n   * @param {Date}\n   */\n\n\n  RRuleSet.prototype.exdate = function (date) {\n    _addDate(date, this._exdate);\n  };\n  /**\n   * Get list of included rrules in this recurrence set.\n   *\n   * @return List of rrules\n   */\n\n\n  RRuleSet.prototype.rrules = function () {\n    return this._rrule.map(function (e) {\n      return rrulestr(e.toString());\n    });\n  };\n  /**\n   * Get list of excluded rrules in this recurrence set.\n   *\n   * @return List of exrules\n   */\n\n\n  RRuleSet.prototype.exrules = function () {\n    return this._exrule.map(function (e) {\n      return rrulestr(e.toString());\n    });\n  };\n  /**\n   * Get list of included datetimes in this recurrence set.\n   *\n   * @return List of rdates\n   */\n\n\n  RRuleSet.prototype.rdates = function () {\n    return this._rdate.map(function (e) {\n      return new Date(e.getTime());\n    });\n  };\n  /**\n   * Get list of included datetimes in this recurrence set.\n   *\n   * @return List of exdates\n   */\n\n\n  RRuleSet.prototype.exdates = function () {\n    return this._exdate.map(function (e) {\n      return new Date(e.getTime());\n    });\n  };\n\n  RRuleSet.prototype.valueOf = function () {\n    var result = [];\n\n    if (!this._rrule.length && this._dtstart) {\n      result = result.concat(optionsToString({\n        dtstart: this._dtstart\n      }));\n    }\n\n    this._rrule.forEach(function (rrule) {\n      result = result.concat(rrule.toString().split('\\n'));\n    });\n\n    this._exrule.forEach(function (exrule) {\n      result = result.concat(exrule.toString().split('\\n').map(function (line) {\n        return line.replace(/^RRULE:/, 'EXRULE:');\n      }).filter(function (line) {\n        return !/^DTSTART/.test(line);\n      }));\n    });\n\n    if (this._rdate.length) {\n      result.push(rdatesToString('RDATE', this._rdate, this.tzid()));\n    }\n\n    if (this._exdate.length) {\n      result.push(rdatesToString('EXDATE', this._exdate, this.tzid()));\n    }\n\n    return result;\n  };\n  /**\n   * to generate recurrence field such as:\n   *   DTSTART:19970902T010000Z\n   *   RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU\n   *   RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH\n   */\n\n\n  RRuleSet.prototype.toString = function () {\n    return this.valueOf().join('\\n');\n  };\n  /**\n   * Create a new RRuleSet Object completely base on current instance\n   */\n\n\n  RRuleSet.prototype.clone = function () {\n    var rrs = new RRuleSet(!!this._cache);\n\n    this._rrule.forEach(function (rule) {\n      return rrs.rrule(rule.clone());\n    });\n\n    this._exrule.forEach(function (rule) {\n      return rrs.exrule(rule.clone());\n    });\n\n    this._rdate.forEach(function (date) {\n      return rrs.rdate(new Date(date.getTime()));\n    });\n\n    this._exdate.forEach(function (date) {\n      return rrs.exdate(new Date(date.getTime()));\n    });\n\n    return rrs;\n  };\n\n  return RRuleSet;\n}(RRule);\n\nexport default RRuleSet;\n\nfunction _addRule(rrule, collection) {\n  if (!(rrule instanceof RRule)) {\n    throw new TypeError(String(rrule) + ' is not RRule instance');\n  }\n\n  if (!includes(collection.map(String), String(rrule))) {\n    collection.push(rrule);\n  }\n}\n\nfunction _addDate(date, collection) {\n  if (!(date instanceof Date)) {\n    throw new TypeError(String(date) + ' is not Date instance');\n  }\n\n  if (!includes(collection.map(Number), Number(date))) {\n    collection.push(date);\n    dateutil.sort(collection);\n  }\n}\n\nfunction rdatesToString(param, rdates, tzid) {\n  var isUTC = !tzid || tzid.toUpperCase() === 'UTC';\n  var header = isUTC ? param + \":\" : param + \";TZID=\" + tzid + \":\";\n  var dateString = rdates.map(function (rdate) {\n    return dateutil.timeToUntilString(rdate.valueOf(), isUTC);\n  }).join(',');\n  return \"\" + header + dateString;\n}","map":null,"metadata":{},"sourceType":"module"}