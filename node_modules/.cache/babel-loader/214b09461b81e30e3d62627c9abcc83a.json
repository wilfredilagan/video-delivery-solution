{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _index = require('./index');\n\nvar _DnDTypes = require('./DnDTypes');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DnDSource = function DnDSource(resolveDragObjFunc, DecoratedComponent) {\n  var _this = this;\n\n  var dndType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _DnDTypes.DnDTypes.EVENT;\n\n  _classCallCheck(this, DnDSource);\n\n  this.getDragSpec = function () {\n    return {\n      beginDrag: function beginDrag(props, monitor, component) {\n        return _this.resolveDragObjFunc(props);\n      },\n      endDrag: function endDrag(props, monitor, component) {\n        if (!monitor.didDrop()) return;\n        var moveEvent = props.moveEvent,\n            newEvent = props.newEvent,\n            schedulerData = props.schedulerData;\n        var events = schedulerData.events,\n            config = schedulerData.config,\n            viewType = schedulerData.viewType,\n            localeMoment = schedulerData.localeMoment;\n        var item = monitor.getItem();\n        var type = monitor.getItemType();\n        var dropResult = monitor.getDropResult();\n        var slotId = dropResult.slotId,\n            slotName = dropResult.slotName;\n        var newStart = dropResult.start,\n            newEnd = dropResult.end;\n        var initialStart = dropResult.initialStart,\n            initialEnd = dropResult.initialEnd;\n        var action = 'New';\n        var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n\n        if (isEvent) {\n          var event = item;\n\n          if (config.relativeMove) {\n            newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n          } else {\n            if (viewType !== _index.ViewTypes.Day) {\n              var tmpMoment = localeMoment(newStart);\n              newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n            }\n          }\n\n          newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n          if (config.crossResourceMove === false) {\n            slotId = schedulerData._getEventSlotId(item);\n            slotName = undefined;\n            var slot = schedulerData.getSlotById(slotId);\n            if (!!slot) slotName = slot.name;\n          }\n\n          action = 'Move';\n        }\n\n        var hasConflict = false;\n\n        if (config.checkConflict) {\n          var start = localeMoment(newStart),\n              end = localeMoment(newEnd);\n          events.forEach(function (e) {\n            if (schedulerData._getEventSlotId(e) === slotId && (!isEvent || e.id !== item.id)) {\n              var eStart = localeMoment(e.start),\n                  eEnd = localeMoment(e.end);\n              if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n            }\n          });\n        }\n\n        if (hasConflict) {\n          var conflictOccurred = props.conflictOccurred;\n\n          if (conflictOccurred != undefined) {\n            conflictOccurred(schedulerData, action, item, type, slotId, slotName, newStart, newEnd);\n          } else {\n            console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n          }\n        } else {\n          if (isEvent) {\n            if (moveEvent !== undefined) {\n              moveEvent(schedulerData, item, slotId, slotName, newStart, newEnd);\n            }\n          } else {\n            if (newEvent !== undefined) newEvent(schedulerData, slotId, slotName, newStart, newEnd, type, item);\n          }\n        }\n      },\n      canDrag: function canDrag(props) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n\n        var item = _this.resolveDragObjFunc(props);\n\n        if (schedulerData._isResizing()) return false;\n        var config = schedulerData.config;\n        return config.movable && (resourceEvents == undefined || !resourceEvents.groupOnly) && (item.movable == undefined || item.movable !== false);\n      }\n    };\n  };\n\n  this.getDragCollect = function (connect, monitor) {\n    return {\n      connectDragSource: connect.dragSource(),\n      isDragging: monitor.isDragging(),\n      connectDragPreview: connect.dragPreview()\n    };\n  };\n\n  this.getDragSource = function () {\n    return _this.dragSource;\n  };\n\n  this.resolveDragObjFunc = resolveDragObjFunc;\n  this.DecoratedComponent = DecoratedComponent;\n  this.dndType = dndType;\n  this.dragSource = (0, _reactDnd.DragSource)(this.dndType, this.getDragSpec(), this.getDragCollect)(this.DecoratedComponent);\n};\n\nexports.default = DnDSource;","map":null,"metadata":{},"sourceType":"script"}