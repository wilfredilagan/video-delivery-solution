{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp, _initialiseProps;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _popover = require('antd/lib/popover');\n\nvar _popover2 = _interopRequireDefault(_popover);\n\nrequire('antd/lib/popover/style/index.css');\n\nvar _EventItemPopover = require('./EventItemPopover');\n\nvar _EventItemPopover2 = _interopRequireDefault(_EventItemPopover);\n\nvar _index = require('./index');\n\nvar _DnDTypes = require('./DnDTypes');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar supportTouch = 'ontouchstart' in window;\nvar EventItem = (_temp = _class = function (_Component) {\n  _inherits(EventItem, _Component);\n\n  function EventItem(props) {\n    _classCallCheck(this, EventItem);\n\n    var _this = _possibleConstructorReturn(this, (EventItem.__proto__ || Object.getPrototypeOf(EventItem)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var left = props.left,\n        top = props.top,\n        width = props.width;\n    _this.state = {\n      left: left,\n      top: top,\n      width: width\n    };\n    _this.startResizer = null;\n    _this.endResizer = null;\n    return _this;\n  }\n\n  _createClass(EventItem, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(np) {\n      var left = np.left,\n          top = np.top,\n          width = np.width;\n      this.setState({\n        left: left,\n        top: top,\n        width: width\n      });\n      this.subscribeResizeEvent(np);\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.subscribeResizeEvent(this.props);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          eventItem = _props.eventItem,\n          isStart = _props.isStart,\n          isEnd = _props.isEnd,\n          isInPopover = _props.isInPopover,\n          eventItemClick = _props.eventItemClick,\n          schedulerData = _props.schedulerData,\n          isDragging = _props.isDragging,\n          connectDragSource = _props.connectDragSource,\n          connectDragPreview = _props.connectDragPreview,\n          eventItemTemplateResolver = _props.eventItemTemplateResolver;\n      var config = schedulerData.config,\n          localeMoment = schedulerData.localeMoment;\n      var _state = this.state,\n          left = _state.left,\n          width = _state.width,\n          top = _state.top;\n      var roundCls = isStart ? isEnd ? 'round-all' : 'round-head' : isEnd ? 'round-tail' : 'round-none';\n      var bgColor = config.defaultEventBgColor;\n      if (!!eventItem.bgColor) bgColor = eventItem.bgColor;\n      var titleText = schedulerData.behaviors.getEventTextFunc(schedulerData, eventItem);\n\n      var content = _react2.default.createElement(_EventItemPopover2.default, _extends({}, this.props, {\n        eventItem: eventItem,\n        title: eventItem.title,\n        startTime: eventItem.start,\n        endTime: eventItem.end,\n        statusColor: bgColor\n      }));\n\n      var start = localeMoment(eventItem.start);\n      var eventTitle = isInPopover ? start.format('HH:mm') + ' ' + titleText : titleText;\n\n      var startResizeDiv = _react2.default.createElement('div', null);\n\n      if (this.startResizable(this.props)) startResizeDiv = _react2.default.createElement('div', {\n        className: 'event-resizer event-start-resizer',\n        ref: function ref(_ref) {\n          return _this2.startResizer = _ref;\n        }\n      });\n\n      var endResizeDiv = _react2.default.createElement('div', null);\n\n      if (this.endResizable(this.props)) endResizeDiv = _react2.default.createElement('div', {\n        className: 'event-resizer event-end-resizer',\n        ref: function ref(_ref2) {\n          return _this2.endResizer = _ref2;\n        }\n      });\n\n      var eventItemTemplate = _react2.default.createElement('div', {\n        className: roundCls + ' event-item',\n        key: eventItem.id,\n        style: {\n          height: config.eventItemHeight,\n          backgroundColor: bgColor\n        }\n      }, _react2.default.createElement('span', {\n        style: {\n          marginLeft: '10px',\n          lineHeight: config.eventItemHeight + 'px'\n        }\n      }, eventTitle));\n\n      if (eventItemTemplateResolver != undefined) eventItemTemplate = eventItemTemplateResolver(schedulerData, eventItem, bgColor, isStart, isEnd, 'event-item', config.eventItemHeight, undefined);\n\n      var a = _react2.default.createElement('a', {\n        className: 'timeline-event',\n        style: {\n          left: left,\n          width: width,\n          top: top\n        },\n        onClick: function onClick() {\n          if (!!eventItemClick) eventItemClick(schedulerData, eventItem);\n        }\n      }, eventItemTemplate, startResizeDiv, endResizeDiv);\n\n      return isDragging ? null : schedulerData._isResizing() || config.eventItemPopoverEnabled == false || eventItem.showPopover == false ? _react2.default.createElement('div', null, connectDragPreview(connectDragSource(a))) : _react2.default.createElement(_popover2.default, {\n        placement: 'bottomLeft',\n        content: content,\n        trigger: 'hover'\n      }, connectDragPreview(connectDragSource(a)));\n    }\n  }]);\n\n  return EventItem;\n}(_react.Component), _class.propTypes = {\n  schedulerData: _propTypes.PropTypes.object.isRequired,\n  eventItem: _propTypes.PropTypes.object.isRequired,\n  isStart: _propTypes.PropTypes.bool.isRequired,\n  isEnd: _propTypes.PropTypes.bool.isRequired,\n  left: _propTypes.PropTypes.number.isRequired,\n  width: _propTypes.PropTypes.number.isRequired,\n  top: _propTypes.PropTypes.number.isRequired,\n  isInPopover: _propTypes.PropTypes.bool.isRequired,\n  leftIndex: _propTypes.PropTypes.number.isRequired,\n  rightIndex: _propTypes.PropTypes.number.isRequired,\n  isDragging: _propTypes.PropTypes.bool.isRequired,\n  connectDragSource: _propTypes.PropTypes.func.isRequired,\n  connectDragPreview: _propTypes.PropTypes.func.isRequired,\n  updateEventStart: _propTypes.PropTypes.func,\n  updateEventEnd: _propTypes.PropTypes.func,\n  moveEvent: _propTypes.PropTypes.func,\n  subtitleGetter: _propTypes.PropTypes.func,\n  eventItemClick: _propTypes.PropTypes.func,\n  viewEventClick: _propTypes.PropTypes.func,\n  viewEventText: _propTypes.PropTypes.string,\n  viewEvent2Click: _propTypes.PropTypes.func,\n  viewEvent2Text: _propTypes.PropTypes.string,\n  conflictOccurred: _propTypes.PropTypes.func,\n  eventItemTemplateResolver: _propTypes.PropTypes.func\n}, _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.initStartDrag = function (ev) {\n    var _props2 = _this3.props,\n        schedulerData = _props2.schedulerData,\n        eventItem = _props2.eventItem;\n\n    var slotId = schedulerData._getEventSlotId(eventItem);\n\n    var slot = schedulerData.getSlotById(slotId);\n    if (!!slot && !!slot.groupOnly) return;\n    if (schedulerData._isResizing()) return;\n    ev.stopPropagation();\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) return;\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      if (ev.buttons !== undefined && ev.buttons !== 1) return;\n      clientX = ev.clientX;\n    }\n\n    _this3.setState({\n      startX: clientX\n    });\n\n    schedulerData._startResizing();\n\n    if (supportTouch) {\n      _this3.startResizer.addEventListener('touchmove', _this3.doStartDrag, false);\n\n      _this3.startResizer.addEventListener('touchend', _this3.stopStartDrag, false);\n\n      _this3.startResizer.addEventListener('touchcancel', _this3.cancelStartDrag, false);\n    } else {\n      document.documentElement.addEventListener('mousemove', _this3.doStartDrag, false);\n      document.documentElement.addEventListener('mouseup', _this3.stopStartDrag, false);\n    }\n\n    document.onselectstart = function () {\n      return false;\n    };\n\n    document.ondragstart = function () {\n      return false;\n    };\n  };\n\n  this.doStartDrag = function (ev) {\n    ev.stopPropagation();\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) return;\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      clientX = ev.clientX;\n    }\n\n    var _props3 = _this3.props,\n        left = _props3.left,\n        width = _props3.width,\n        leftIndex = _props3.leftIndex,\n        rightIndex = _props3.rightIndex,\n        schedulerData = _props3.schedulerData;\n    var cellWidth = schedulerData.getContentCellWidth();\n    var offset = leftIndex > 0 ? 5 : 6;\n    var minWidth = cellWidth - offset;\n    var maxWidth = rightIndex * cellWidth - offset;\n    var startX = _this3.state.startX;\n    var newLeft = left + clientX - startX;\n    var newWidth = width + startX - clientX;\n\n    if (newWidth < minWidth) {\n      newWidth = minWidth;\n      newLeft = (rightIndex - 1) * cellWidth + (rightIndex - 1 > 0 ? 2 : 3);\n    } else if (newWidth > maxWidth) {\n      newWidth = maxWidth;\n      newLeft = 3;\n    }\n\n    _this3.setState({\n      left: newLeft,\n      width: newWidth\n    });\n  };\n\n  this.stopStartDrag = function (ev) {\n    ev.stopPropagation();\n\n    if (supportTouch) {\n      _this3.startResizer.removeEventListener('touchmove', _this3.doStartDrag, false);\n\n      _this3.startResizer.removeEventListener('touchend', _this3.stopStartDrag, false);\n\n      _this3.startResizer.removeEventListener('touchcancel', _this3.cancelStartDrag, false);\n    } else {\n      document.documentElement.removeEventListener('mousemove', _this3.doStartDrag, false);\n      document.documentElement.removeEventListener('mouseup', _this3.stopStartDrag, false);\n    }\n\n    document.onselectstart = null;\n    document.ondragstart = null;\n    var _props4 = _this3.props,\n        width = _props4.width,\n        left = _props4.left,\n        top = _props4.top,\n        leftIndex = _props4.leftIndex,\n        rightIndex = _props4.rightIndex,\n        schedulerData = _props4.schedulerData,\n        eventItem = _props4.eventItem,\n        updateEventStart = _props4.updateEventStart,\n        conflictOccurred = _props4.conflictOccurred;\n\n    schedulerData._stopResizing();\n\n    if (_this3.state.width === width) return;\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) {\n        _this3.setState({\n          left: left,\n          top: top,\n          width: width\n        });\n\n        return;\n      }\n\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      clientX = ev.clientX;\n    }\n\n    var cellUnit = schedulerData.cellUnit,\n        events = schedulerData.events,\n        config = schedulerData.config,\n        localeMoment = schedulerData.localeMoment;\n    var cellWidth = schedulerData.getContentCellWidth();\n    var offset = leftIndex > 0 ? 5 : 6;\n    var minWidth = cellWidth - offset;\n    var maxWidth = rightIndex * cellWidth - offset;\n    var startX = _this3.state.startX;\n    var newWidth = width + startX - clientX;\n    var deltaX = clientX - startX;\n    var sign = deltaX < 0 ? -1 : deltaX === 0 ? 0 : 1;\n    var count = (sign > 0 ? Math.floor(Math.abs(deltaX) / cellWidth) : Math.ceil(Math.abs(deltaX) / cellWidth)) * sign;\n    if (newWidth < minWidth) count = rightIndex - leftIndex - 1;else if (newWidth > maxWidth) count = -leftIndex;\n    var newStart = localeMoment(eventItem.start).add(cellUnit === _index.CellUnits.Hour ? count * config.minuteStep : count, cellUnit === _index.CellUnits.Hour ? 'minutes' : 'days').format(_index.DATETIME_FORMAT);\n\n    if (count !== 0 && cellUnit !== _index.CellUnits.Hour && config.displayWeekend === false) {\n      if (count > 0) {\n        var tempCount = 0,\n            i = 0;\n\n        while (true) {\n          i++;\n          var tempStart = localeMoment(eventItem.start).add(i, 'days');\n          var dayOfWeek = tempStart.weekday();\n\n          if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n            tempCount++;\n\n            if (tempCount === count) {\n              newStart = tempStart.format(_index.DATETIME_FORMAT);\n              break;\n            }\n          }\n        }\n      } else {\n        var _tempCount = 0,\n            _i = 0;\n\n        while (true) {\n          _i--;\n\n          var _tempStart = localeMoment(eventItem.start).add(_i, 'days');\n\n          var _dayOfWeek = _tempStart.weekday();\n\n          if (_dayOfWeek !== 0 && _dayOfWeek !== 6) {\n            _tempCount--;\n\n            if (_tempCount === count) {\n              newStart = _tempStart.format(_index.DATETIME_FORMAT);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    var hasConflict = false;\n\n    var slotId = schedulerData._getEventSlotId(eventItem);\n\n    var slotName = undefined;\n    var slot = schedulerData.getSlotById(slotId);\n    if (!!slot) slotName = slot.name;\n\n    if (config.checkConflict) {\n      var start = localeMoment(newStart),\n          end = localeMoment(eventItem.end);\n      events.forEach(function (e) {\n        if (schedulerData._getEventSlotId(e) === slotId && e.id !== eventItem.id) {\n          var eStart = localeMoment(e.start),\n              eEnd = localeMoment(e.end);\n          if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n        }\n      });\n    }\n\n    if (hasConflict) {\n      _this3.setState({\n        left: left,\n        top: top,\n        width: width\n      });\n\n      if (conflictOccurred != undefined) {\n        conflictOccurred(schedulerData, 'StartResize', eventItem, _DnDTypes.DnDTypes.EVENT, slotId, slotName, newStart, eventItem.end);\n      } else {\n        console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n      }\n\n      _this3.subscribeResizeEvent(_this3.props);\n    } else {\n      if (updateEventStart != undefined) updateEventStart(schedulerData, eventItem, newStart);\n    }\n  };\n\n  this.cancelStartDrag = function (ev) {\n    ev.stopPropagation();\n\n    _this3.startResizer.removeEventListener('touchmove', _this3.doStartDrag, false);\n\n    _this3.startResizer.removeEventListener('touchend', _this3.stopStartDrag, false);\n\n    _this3.startResizer.removeEventListener('touchcancel', _this3.cancelStartDrag, false);\n\n    document.onselectstart = null;\n    document.ondragstart = null;\n    var _props5 = _this3.props,\n        schedulerData = _props5.schedulerData,\n        left = _props5.left,\n        top = _props5.top,\n        width = _props5.width;\n\n    schedulerData._stopResizing();\n\n    _this3.setState({\n      left: left,\n      top: top,\n      width: width\n    });\n  };\n\n  this.initEndDrag = function (ev) {\n    var _props6 = _this3.props,\n        schedulerData = _props6.schedulerData,\n        eventItem = _props6.eventItem;\n\n    var slotId = schedulerData._getEventSlotId(eventItem);\n\n    var slot = schedulerData.getSlotById(slotId);\n    if (!!slot && !!slot.groupOnly) return;\n    if (schedulerData._isResizing()) return;\n    ev.stopPropagation();\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) return;\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      if (ev.buttons !== undefined && ev.buttons !== 1) return;\n      clientX = ev.clientX;\n    }\n\n    _this3.setState({\n      endX: clientX\n    });\n\n    schedulerData._startResizing();\n\n    if (supportTouch) {\n      _this3.endResizer.addEventListener('touchmove', _this3.doEndDrag, false);\n\n      _this3.endResizer.addEventListener('touchend', _this3.stopEndDrag, false);\n\n      _this3.endResizer.addEventListener('touchcancel', _this3.cancelEndDrag, false);\n    } else {\n      document.documentElement.addEventListener('mousemove', _this3.doEndDrag, false);\n      document.documentElement.addEventListener('mouseup', _this3.stopEndDrag, false);\n    }\n\n    document.onselectstart = function () {\n      return false;\n    };\n\n    document.ondragstart = function () {\n      return false;\n    };\n  };\n\n  this.doEndDrag = function (ev) {\n    ev.stopPropagation();\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) return;\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      clientX = ev.clientX;\n    }\n\n    var _props7 = _this3.props,\n        width = _props7.width,\n        leftIndex = _props7.leftIndex,\n        schedulerData = _props7.schedulerData;\n    var headers = schedulerData.headers;\n    var cellWidth = schedulerData.getContentCellWidth();\n    var offset = leftIndex > 0 ? 5 : 6;\n    var minWidth = cellWidth - offset;\n    var maxWidth = (headers.length - leftIndex) * cellWidth - offset;\n    var endX = _this3.state.endX;\n    var newWidth = width + clientX - endX;\n    if (newWidth < minWidth) newWidth = minWidth;else if (newWidth > maxWidth) newWidth = maxWidth;\n\n    _this3.setState({\n      width: newWidth\n    });\n  };\n\n  this.stopEndDrag = function (ev) {\n    ev.stopPropagation();\n\n    if (supportTouch) {\n      _this3.endResizer.removeEventListener('touchmove', _this3.doEndDrag, false);\n\n      _this3.endResizer.removeEventListener('touchend', _this3.stopEndDrag, false);\n\n      _this3.endResizer.removeEventListener('touchcancel', _this3.cancelEndDrag, false);\n    } else {\n      document.documentElement.removeEventListener('mousemove', _this3.doEndDrag, false);\n      document.documentElement.removeEventListener('mouseup', _this3.stopEndDrag, false);\n    }\n\n    document.onselectstart = null;\n    document.ondragstart = null;\n    var _props8 = _this3.props,\n        width = _props8.width,\n        left = _props8.left,\n        top = _props8.top,\n        leftIndex = _props8.leftIndex,\n        rightIndex = _props8.rightIndex,\n        schedulerData = _props8.schedulerData,\n        eventItem = _props8.eventItem,\n        updateEventEnd = _props8.updateEventEnd,\n        conflictOccurred = _props8.conflictOccurred;\n\n    schedulerData._stopResizing();\n\n    if (_this3.state.width === width) return;\n    var clientX = 0;\n\n    if (supportTouch) {\n      if (ev.changedTouches.length == 0) {\n        _this3.setState({\n          left: left,\n          top: top,\n          width: width\n        });\n\n        return;\n      }\n\n      var touch = ev.changedTouches[0];\n      clientX = touch.pageX;\n    } else {\n      clientX = ev.clientX;\n    }\n\n    var headers = schedulerData.headers,\n        cellUnit = schedulerData.cellUnit,\n        events = schedulerData.events,\n        config = schedulerData.config,\n        localeMoment = schedulerData.localeMoment;\n    var cellWidth = schedulerData.getContentCellWidth();\n    var offset = leftIndex > 0 ? 5 : 6;\n    var minWidth = cellWidth - offset;\n    var maxWidth = (headers.length - leftIndex) * cellWidth - offset;\n    var endX = _this3.state.endX;\n    var newWidth = width + clientX - endX;\n    var deltaX = newWidth - width;\n    var sign = deltaX < 0 ? -1 : deltaX === 0 ? 0 : 1;\n    var count = (sign < 0 ? Math.floor(Math.abs(deltaX) / cellWidth) : Math.ceil(Math.abs(deltaX) / cellWidth)) * sign;\n    if (newWidth < minWidth) count = leftIndex - rightIndex + 1;else if (newWidth > maxWidth) count = headers.length - rightIndex;\n    var newEnd = localeMoment(eventItem.end).add(cellUnit === _index.CellUnits.Hour ? count * config.minuteStep : count, cellUnit === _index.CellUnits.Hour ? 'minutes' : 'days').format(_index.DATETIME_FORMAT);\n\n    if (count !== 0 && cellUnit !== _index.CellUnits.Hour && config.displayWeekend === false) {\n      if (count > 0) {\n        var tempCount = 0,\n            i = 0;\n\n        while (true) {\n          i++;\n          var tempEnd = localeMoment(eventItem.end).add(i, 'days');\n          var dayOfWeek = tempEnd.weekday();\n\n          if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n            tempCount++;\n\n            if (tempCount === count) {\n              newEnd = tempEnd.format(_index.DATETIME_FORMAT);\n              break;\n            }\n          }\n        }\n      } else {\n        var _tempCount2 = 0,\n            _i2 = 0;\n\n        while (true) {\n          _i2--;\n\n          var _tempEnd = localeMoment(eventItem.end).add(_i2, 'days');\n\n          var _dayOfWeek2 = _tempEnd.weekday();\n\n          if (_dayOfWeek2 !== 0 && _dayOfWeek2 !== 6) {\n            _tempCount2--;\n\n            if (_tempCount2 === count) {\n              newEnd = _tempEnd.format(_index.DATETIME_FORMAT);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    var hasConflict = false;\n\n    var slotId = schedulerData._getEventSlotId(eventItem);\n\n    var slotName = undefined;\n    var slot = schedulerData.getSlotById(slotId);\n    if (!!slot) slotName = slot.name;\n\n    if (config.checkConflict) {\n      var start = localeMoment(eventItem.start),\n          end = localeMoment(newEnd);\n      events.forEach(function (e) {\n        if (schedulerData._getEventSlotId(e) === slotId && e.id !== eventItem.id) {\n          var eStart = localeMoment(e.start),\n              eEnd = localeMoment(e.end);\n          if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n        }\n      });\n    }\n\n    if (hasConflict) {\n      _this3.setState({\n        left: left,\n        top: top,\n        width: width\n      });\n\n      if (conflictOccurred != undefined) {\n        conflictOccurred(schedulerData, 'EndResize', eventItem, _DnDTypes.DnDTypes.EVENT, slotId, slotName, eventItem.start, newEnd);\n      } else {\n        console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n      }\n\n      _this3.subscribeResizeEvent(_this3.props);\n    } else {\n      if (updateEventEnd != undefined) updateEventEnd(schedulerData, eventItem, newEnd);\n    }\n  };\n\n  this.cancelEndDrag = function (ev) {\n    ev.stopPropagation();\n\n    _this3.endResizer.removeEventListener('touchmove', _this3.doEndDrag, false);\n\n    _this3.endResizer.removeEventListener('touchend', _this3.stopEndDrag, false);\n\n    _this3.endResizer.removeEventListener('touchcancel', _this3.cancelEndDrag, false);\n\n    document.onselectstart = null;\n    document.ondragstart = null;\n    var _props9 = _this3.props,\n        schedulerData = _props9.schedulerData,\n        left = _props9.left,\n        top = _props9.top,\n        width = _props9.width;\n\n    schedulerData._stopResizing();\n\n    _this3.setState({\n      left: left,\n      top: top,\n      width: width\n    });\n  };\n\n  this.startResizable = function (props) {\n    var eventItem = props.eventItem,\n        isInPopover = props.isInPopover,\n        schedulerData = props.schedulerData;\n    var config = schedulerData.config;\n    return config.startResizable === true && isInPopover === false && (eventItem.resizable == undefined || eventItem.resizable !== false) && (eventItem.startResizable == undefined || eventItem.startResizable !== false);\n  };\n\n  this.endResizable = function (props) {\n    var eventItem = props.eventItem,\n        isInPopover = props.isInPopover,\n        schedulerData = props.schedulerData;\n    var config = schedulerData.config;\n    return config.endResizable === true && isInPopover === false && (eventItem.resizable == undefined || eventItem.resizable !== false) && (eventItem.endResizable == undefined || eventItem.endResizable !== false);\n  };\n\n  this.subscribeResizeEvent = function (props) {\n    if (_this3.startResizer != undefined) {\n      if (supportTouch) {// this.startResizer.removeEventListener('touchstart', this.initStartDrag, false);\n        // if (this.startResizable(props))\n        //     this.startResizer.addEventListener('touchstart', this.initStartDrag, false);\n      } else {\n        _this3.startResizer.removeEventListener('mousedown', _this3.initStartDrag, false);\n\n        if (_this3.startResizable(props)) _this3.startResizer.addEventListener('mousedown', _this3.initStartDrag, false);\n      }\n    }\n\n    if (_this3.endResizer != undefined) {\n      if (supportTouch) {// this.endResizer.removeEventListener('touchstart', this.initEndDrag, false);\n        // if (this.endResizable(props))\n        //     this.endResizer.addEventListener('touchstart', this.initEndDrag, false);\n      } else {\n        _this3.endResizer.removeEventListener('mousedown', _this3.initEndDrag, false);\n\n        if (_this3.endResizable(props)) _this3.endResizer.addEventListener('mousedown', _this3.initEndDrag, false);\n      }\n    }\n  };\n}, _temp);\nexports.default = EventItem;","map":null,"metadata":{},"sourceType":"script"}