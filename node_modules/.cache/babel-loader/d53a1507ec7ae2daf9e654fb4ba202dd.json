{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _Util = require('./Util');\n\nvar _DnDTypes = require('./DnDTypes');\n\nvar _index = require('./index');\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DnDContext = function DnDContext(sources, DecoratedComponent) {\n  var _this = this;\n\n  _classCallCheck(this, DnDContext);\n\n  this.getDropSpec = function () {\n    return {\n      drop: function drop(props, monitor, component) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n        var cellUnit = schedulerData.cellUnit,\n            localeMoment = schedulerData.localeMoment;\n        var type = monitor.getItemType();\n        var pos = (0, _Util.getPos)(component.eventContainer);\n        var cellWidth = schedulerData.getContentCellWidth();\n        var initialStartTime = null,\n            initialEndTime = null;\n\n        if (type === _DnDTypes.DnDTypes.EVENT) {\n          var initialPoint = monitor.getInitialClientOffset();\n          var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n          initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n          initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n          if (cellUnit !== _index.CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        }\n\n        var point = monitor.getClientOffset();\n        var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n        var startTime = resourceEvents.headerItems[leftIndex].start;\n        var endTime = resourceEvents.headerItems[leftIndex].end;\n        if (cellUnit !== _index.CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        return {\n          slotId: resourceEvents.slotId,\n          slotName: resourceEvents.slotName,\n          start: startTime,\n          end: endTime,\n          initialStart: initialStartTime,\n          initialEnd: initialEndTime\n        };\n      },\n      hover: function hover(props, monitor, component) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents,\n            movingEvent = props.movingEvent;\n        var cellUnit = schedulerData.cellUnit,\n            config = schedulerData.config,\n            viewType = schedulerData.viewType,\n            localeMoment = schedulerData.localeMoment;\n        var item = monitor.getItem();\n        var type = monitor.getItemType();\n        var pos = (0, _Util.getPos)(component.eventContainer);\n        var cellWidth = schedulerData.getContentCellWidth();\n        var initialStart = null,\n            initialEnd = null;\n\n        if (type === _DnDTypes.DnDTypes.EVENT) {\n          var initialPoint = monitor.getInitialClientOffset();\n          var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n          initialStart = resourceEvents.headerItems[initialLeftIndex].start;\n          initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\n          if (cellUnit !== _index.CellUnits.Hour) initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        }\n\n        var point = monitor.getClientOffset();\n        var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n        var newStart = resourceEvents.headerItems[leftIndex].start;\n        var newEnd = resourceEvents.headerItems[leftIndex].end;\n        if (cellUnit !== _index.CellUnits.Hour) newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        var slotId = resourceEvents.slotId,\n            slotName = resourceEvents.slotName;\n        var action = 'New';\n        var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n\n        if (isEvent) {\n          var event = item;\n\n          if (config.relativeMove) {\n            newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n          } else {\n            if (viewType !== ViewTypes.Day) {\n              var tmpMoment = localeMoment(newStart);\n              newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n            }\n          }\n\n          newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n          if (config.crossResourceMove === false) {\n            slotId = schedulerData._getEventSlotId(item);\n            slotName = undefined;\n            var slot = schedulerData.getSlotById(slotId);\n            if (!!slot) slotName = slot.name;\n          }\n\n          action = 'Move';\n        }\n\n        if (!!movingEvent) {\n          movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\n        }\n      },\n      canDrop: function canDrop(props, monitor) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n        var item = monitor.getItem();\n        if (schedulerData._isResizing()) return false;\n        var config = schedulerData.config;\n        return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\n      }\n    };\n  };\n\n  this.getDropCollect = function (connect, monitor) {\n    return {\n      connectDropTarget: connect.dropTarget(),\n      isOver: monitor.isOver()\n    };\n  };\n\n  this.getDropTarget = function () {\n    return (0, _reactDnd.DropTarget)([].concat(_toConsumableArray(_this.sourceMap.keys())), _this.getDropSpec(), _this.getDropCollect)(_this.DecoratedComponent);\n  };\n\n  this.getDndSource = function () {\n    var dndType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DnDTypes.DnDTypes.EVENT;\n    return _this.sourceMap.get(dndType);\n  };\n\n  this.sourceMap = new Map();\n  sources.forEach(function (item) {\n    _this.sourceMap.set(item.dndType, item);\n  });\n  this.DecoratedComponent = DecoratedComponent;\n};\n\nexports.default = DnDContext;","map":null,"metadata":{},"sourceType":"script"}