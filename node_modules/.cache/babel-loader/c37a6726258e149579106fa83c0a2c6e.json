{"ast":null,"code":"import ENGLISH from './i18n';\nimport RRule from '../index'; // =============================================================================\n// Parser\n// =============================================================================\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(rules) {\n    this.done = true;\n    this.rules = rules;\n  }\n\n  Parser.prototype.start = function (text) {\n    this.text = text;\n    this.done = false;\n    return this.nextSymbol();\n  };\n\n  Parser.prototype.isDone = function () {\n    return this.done && this.symbol === null;\n  };\n\n  Parser.prototype.nextSymbol = function () {\n    var best;\n    var bestSymbol;\n    var p = this;\n    this.symbol = null;\n    this.value = null;\n\n    do {\n      if (this.done) return false;\n      var rule = void 0;\n      best = null;\n\n      for (var name_1 in this.rules) {\n        rule = this.rules[name_1];\n        var match = rule.exec(p.text);\n\n        if (match) {\n          if (best === null || match[0].length > best[0].length) {\n            best = match;\n            bestSymbol = name_1;\n          }\n        }\n      }\n\n      if (best != null) {\n        this.text = this.text.substr(best[0].length);\n        if (this.text === '') this.done = true;\n      }\n\n      if (best == null) {\n        this.done = true;\n        this.symbol = null;\n        this.value = null;\n        return;\n      } // @ts-ignore\n\n    } while (bestSymbol === 'SKIP'); // @ts-ignore\n\n\n    this.symbol = bestSymbol;\n    this.value = best;\n    return true;\n  };\n\n  Parser.prototype.accept = function (name) {\n    if (this.symbol === name) {\n      if (this.value) {\n        var v = this.value;\n        this.nextSymbol();\n        return v;\n      }\n\n      this.nextSymbol();\n      return true;\n    }\n\n    return false;\n  };\n\n  Parser.prototype.acceptNumber = function () {\n    return this.accept('number');\n  };\n\n  Parser.prototype.expect = function (name) {\n    if (this.accept(name)) return true;\n    throw new Error('expected ' + name + ' but found ' + this.symbol);\n  };\n\n  return Parser;\n}();\n\nexport default function parseText(text, language) {\n  if (language === void 0) {\n    language = ENGLISH;\n  }\n\n  var options = {};\n  var ttr = new Parser(language.tokens);\n  if (!ttr.start(text)) return null;\n  S();\n  return options;\n\n  function S() {\n    // every [n]\n    ttr.expect('every');\n    var n = ttr.acceptNumber();\n    if (n) options.interval = parseInt(n[0], 10);\n    if (ttr.isDone()) throw new Error('Unexpected end');\n\n    switch (ttr.symbol) {\n      case 'day(s)':\n        options.freq = RRule.DAILY;\n\n        if (ttr.nextSymbol()) {\n          AT();\n          F();\n        }\n\n        break;\n      // FIXME Note: every 2 weekdays != every two weeks on weekdays.\n      // DAILY on weekdays is not a valid rule\n\n      case 'weekday(s)':\n        options.freq = RRule.WEEKLY;\n        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];\n        ttr.nextSymbol();\n        F();\n        break;\n\n      case 'week(s)':\n        options.freq = RRule.WEEKLY;\n\n        if (ttr.nextSymbol()) {\n          ON();\n          F();\n        }\n\n        break;\n\n      case 'hour(s)':\n        options.freq = RRule.HOURLY;\n\n        if (ttr.nextSymbol()) {\n          ON();\n          F();\n        }\n\n        break;\n\n      case 'minute(s)':\n        options.freq = RRule.MINUTELY;\n\n        if (ttr.nextSymbol()) {\n          ON();\n          F();\n        }\n\n        break;\n\n      case 'month(s)':\n        options.freq = RRule.MONTHLY;\n\n        if (ttr.nextSymbol()) {\n          ON();\n          F();\n        }\n\n        break;\n\n      case 'year(s)':\n        options.freq = RRule.YEARLY;\n\n        if (ttr.nextSymbol()) {\n          ON();\n          F();\n        }\n\n        break;\n\n      case 'monday':\n      case 'tuesday':\n      case 'wednesday':\n      case 'thursday':\n      case 'friday':\n      case 'saturday':\n      case 'sunday':\n        options.freq = RRule.WEEKLY;\n        var key = ttr.symbol.substr(0, 2).toUpperCase();\n        options.byweekday = [RRule[key]];\n        if (!ttr.nextSymbol()) return; // TODO check for duplicates\n\n        while (ttr.accept('comma')) {\n          if (ttr.isDone()) throw new Error('Unexpected end');\n          var wkd = decodeWKD();\n\n          if (!wkd) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + ', expected weekday');\n          } // @ts-ignore\n\n\n          options.byweekday.push(RRule[wkd]);\n          ttr.nextSymbol();\n        }\n\n        MDAYs();\n        F();\n        break;\n\n      case 'january':\n      case 'february':\n      case 'march':\n      case 'april':\n      case 'may':\n      case 'june':\n      case 'july':\n      case 'august':\n      case 'september':\n      case 'october':\n      case 'november':\n      case 'december':\n        options.freq = RRule.YEARLY;\n        options.bymonth = [decodeM()];\n        if (!ttr.nextSymbol()) return; // TODO check for duplicates\n\n        while (ttr.accept('comma')) {\n          if (ttr.isDone()) throw new Error('Unexpected end');\n          var m = decodeM();\n\n          if (!m) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + ', expected month');\n          }\n\n          options.bymonth.push(m);\n          ttr.nextSymbol();\n        }\n\n        ON();\n        F();\n        break;\n\n      default:\n        throw new Error('Unknown symbol');\n    }\n  }\n\n  function ON() {\n    var on = ttr.accept('on');\n    var the = ttr.accept('the');\n    if (!(on || the)) return;\n\n    do {\n      var nth = decodeNTH();\n      var wkd = decodeWKD();\n      var m = decodeM(); // nth <weekday> | <weekday>\n\n      if (nth) {\n        // ttr.nextSymbol()\n        if (wkd) {\n          ttr.nextSymbol();\n          if (!options.byweekday) options.byweekday = []; // @ts-ignore\n\n          options.byweekday.push(RRule[wkd].nth(nth));\n        } else {\n          if (!options.bymonthday) options.bymonthday = []; // @ts-ignore\n\n          options.bymonthday.push(nth);\n          ttr.accept('day(s)');\n        } // <weekday>\n\n      } else if (wkd) {\n        ttr.nextSymbol();\n        if (!options.byweekday) options.byweekday = []; // @ts-ignore\n\n        options.byweekday.push(RRule[wkd]);\n      } else if (ttr.symbol === 'weekday(s)') {\n        ttr.nextSymbol();\n\n        if (!options.byweekday) {\n          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];\n        }\n      } else if (ttr.symbol === 'week(s)') {\n        ttr.nextSymbol();\n        var n = ttr.acceptNumber();\n\n        if (!n) {\n          throw new Error('Unexpected symbol ' + ttr.symbol + ', expected week number');\n        }\n\n        options.byweekno = [parseInt(n[0], 10)];\n\n        while (ttr.accept('comma')) {\n          n = ttr.acceptNumber();\n\n          if (!n) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday');\n          }\n\n          options.byweekno.push(parseInt(n[0], 10));\n        }\n      } else if (m) {\n        ttr.nextSymbol();\n        if (!options.bymonth) options.bymonth = []; // @ts-ignore\n\n        options.bymonth.push(m);\n      } else {\n        return;\n      }\n    } while (ttr.accept('comma') || ttr.accept('the') || ttr.accept('on'));\n  }\n\n  function AT() {\n    var at = ttr.accept('at');\n    if (!at) return;\n\n    do {\n      var n = ttr.acceptNumber();\n\n      if (!n) {\n        throw new Error('Unexpected symbol ' + ttr.symbol + ', expected hour');\n      }\n\n      options.byhour = [parseInt(n[0], 10)];\n\n      while (ttr.accept('comma')) {\n        n = ttr.acceptNumber();\n\n        if (!n) {\n          throw new Error('Unexpected symbol ' + ttr.symbol + '; expected hour');\n        }\n\n        options.byhour.push(parseInt(n[0], 10));\n      }\n    } while (ttr.accept('comma') || ttr.accept('at'));\n  }\n\n  function decodeM() {\n    switch (ttr.symbol) {\n      case 'january':\n        return 1;\n\n      case 'february':\n        return 2;\n\n      case 'march':\n        return 3;\n\n      case 'april':\n        return 4;\n\n      case 'may':\n        return 5;\n\n      case 'june':\n        return 6;\n\n      case 'july':\n        return 7;\n\n      case 'august':\n        return 8;\n\n      case 'september':\n        return 9;\n\n      case 'october':\n        return 10;\n\n      case 'november':\n        return 11;\n\n      case 'december':\n        return 12;\n\n      default:\n        return false;\n    }\n  }\n\n  function decodeWKD() {\n    switch (ttr.symbol) {\n      case 'monday':\n      case 'tuesday':\n      case 'wednesday':\n      case 'thursday':\n      case 'friday':\n      case 'saturday':\n      case 'sunday':\n        return ttr.symbol.substr(0, 2).toUpperCase();\n\n      default:\n        return false;\n    }\n  }\n\n  function decodeNTH() {\n    switch (ttr.symbol) {\n      case 'last':\n        ttr.nextSymbol();\n        return -1;\n\n      case 'first':\n        ttr.nextSymbol();\n        return 1;\n\n      case 'second':\n        ttr.nextSymbol();\n        return ttr.accept('last') ? -2 : 2;\n\n      case 'third':\n        ttr.nextSymbol();\n        return ttr.accept('last') ? -3 : 3;\n\n      case 'nth':\n        var v = parseInt(ttr.value[1], 10);\n        if (v < -366 || v > 366) throw new Error('Nth out of range: ' + v);\n        ttr.nextSymbol();\n        return ttr.accept('last') ? -v : v;\n\n      default:\n        return false;\n    }\n  }\n\n  function MDAYs() {\n    ttr.accept('on');\n    ttr.accept('the');\n    var nth = decodeNTH();\n    if (!nth) return;\n    options.bymonthday = [nth];\n    ttr.nextSymbol();\n\n    while (ttr.accept('comma')) {\n      nth = decodeNTH();\n\n      if (!nth) {\n        throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday');\n      }\n\n      options.bymonthday.push(nth);\n      ttr.nextSymbol();\n    }\n  }\n\n  function F() {\n    if (ttr.symbol === 'until') {\n      var date = Date.parse(ttr.text);\n      if (!date) throw new Error('Cannot parse until date:' + ttr.text);\n      options.until = new Date(date);\n    } else if (ttr.accept('for')) {\n      options.count = parseInt(ttr.value[0], 10);\n      ttr.expect('number'); // ttr.expect('times')\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}